<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_plant</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Parametros


//mover plant para que el centro caiga en el punto en el q esta la mano de player
//CAMBIAR con el sprite definitivo
x -= 8;

image_speed = 0;
hsp = 0;
vsp = 0;

grav = true;    //variable q sirve para q obj externos activen y desactiven la gravedad de este obj


//Growth        ------------------------------------------------------------------------
//array que contiene:
// en la fila [0] el tama単o de la planta  
// en la fila [1] el numero de columna de la arrawy
// en la [2] la ID del sprite

//variables
growth_distance = global.unit/4;//la distancia entre los centros de cada sprite (y tama単o del sprite)
growth_rythm = 0;               //el tiempo q tarda en crecer
water = false;                  //guarda si se detecta water
water_drop = false;             //guarda si se detecta water_drop
water_range = global.unit*2;    //distancia a la q una fuente de agua hace crecer plant
water_max_range = global.unit;  //distancia maxima a la q plant crece desde el agua
nearest_water = 0;              //guarda la ID del water mas cercano
water_left = false;             //true si "nearest_water" esta a la izquierda
water_right = false;            //true si "nearest_water" esta a la derecha
nearest_flower_to_water = 0;    //guarda la ID de la "flower" mas cercana a water
farthest_flower_to_water = 0;   //guarda la ID de la "flower" mas lejana a water
flower_right = 0;               //flower mas a la derecha
flower_left = 0;                //flower mas a la izquierda
flower_centre = 0;              //flower central
true_x = 0;
flower_even = 0;                //guarda si hay un numero par(true) o impar (false) de flores
nearest_water_drop = 0;         //guarda la ID del water_drop mas cercano
plant_centre = 0;               //guarda la ID de "flower" en la posicion central de la array
growth_alarm = 0;               //alarma para q solo crezca una vez por cada water_drop
larger_flower = 0;              //guarda la posicion en [1, i] del valor mas alto de [0, i]

growth[0, 2] = 0;
growth[0, 1] = 1;
growth[0, 0] = 0;

//array
for(z = 2; z &gt; -1; z -=1)   //guarda el numero de columna, para relaccionarlo en fila [2]
{
    growth[1, z] = z;
}


for(i = 2; i &gt; -1; i -= 1)  //guarda la ID de cada sprite, relaccionando su x con el numero de columna
{
    growth[2, i] = instance_create(x + (growth_distance/2) + (growth_distance *  i), (y -2), obj_flower);
}







</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//incluyo gravedad y colision por si acaso, pero no se si la necesitare en el futuro

//Gravity and Collision -------------------------------------------------------------
if grav == true     
{
    scr_grav();
}

scr_collision();
x += hsp;
y += vsp;

//Growth        ----------------------------------------------------------------------
//              ----------------------------------------------------------------------
//              ----------------------------------------------------------------------

//Al derramar agua sobre Plant, la array crece

//definir las ID de las flores importantes. Izq, Der y central-------------------------
//              -----------------------------------------------------------------------

//ID flower derecha e izquierda
flower_right = growth[2, (array_length_2d(growth, 1)-1)];
flower_left = growth[2, 0];
//ID de  flower central
//CUIDADO si es par, dara la ID de la flor a la IZQ del centro
flower_centre = growth[2,(array_length_2d(growth,1)/2)];

//esto averigua si el numero de flowers es par(true) o inpar(false)
if (frac((array_length_2d(growth, 1))/2) == 0) {flower_even = true;}
else flower_even = false;

//averigua el verdadero centro de Plant
true_x = flower_left.x + ((flower_right.x - flower_left.x) /2)

//Water_drop check  --------------------------------------------------------------------
//                  --------------------------------------------------------------------
//loop q pasa por cada "casilla" de flor, comprueba si hay "water_drop" cerca, y devuelve "water_drop = true"
water_drop = false;     //reinicia la variable cada step para q solo crezca una vez

if instance_exists(obj_water_drop)
{
    for(i = (array_length_2d(growth, 1) -1); i &gt; -1; i -= 1)
    {
        nearest_water_drop = instance_nearest(growth[2, i].x, y, obj_water_drop);
        if ((nearest_water_drop.x - growth[2, i].x) &lt;= (growth_distance/2)) &amp;&amp; ((nearest_water_drop.y - growth[2, i].y) &lt;= (growth_distance/2))
        {
            water_drop = true;
            break    
        }
    }
}

//water check   -----------------------------------------------------------------------------
//              ------------------------------------------------------------------------------------

water = false;     //reinicia la variable cada step para q solo crezca una vez




if instance_exists(obj_water)
{
    nearest_water = instance_nearest(true_x, y, obj_water);   //nearest_water es el obj_water mas cercano al centro de PLant
        if (abs(nearest_water.x - true_x)) &lt;= water_range              //si nearest_water esta dentro de water_range, entonces "water= true"
        {
            water = true
        }
    /*
    //  (       ( agua +cerca de flower_right )             - (flower_right)  ) &lt;= water_range)  o (        lo mismo pero water_left                                                    )
    if (((instance_nearest(flower_right.x, y, obj_water).x) - (flower_right.x)) &lt;= water_range) || (((instance_nearest(flower_left.x, y, obj_water).x) - (flower_left.x)) &lt;= water_range)
    {

    }
    */
}

//Growth water_drop     --------------------------------------------------------------------
if (growth_alarm &gt; 0) growth_alarm -=1;     //alarma para q solo crezca una vez cada cierto tiempo

if (instance_exists(obj_water_drop)) &amp;&amp; (water_drop == true) &amp;&amp; (growth_alarm &lt;= 0)      //regar planta
{
    //los valores de fila[0] suman +1 hasta un maximo de 3 
    for(i = (array_length_2d(growth, 1) -1); i &gt; -1; i -= 1)
    {
        if growth[0, i] &lt; 3
        {
            growth[0, i] += 1;
        }
    }
    //los valores de fila[1] suman +1 
    for(i = (array_length_2d(growth, 1) -1); i &gt; -1; i -= 1)
    {
        growth[1, i] += 1;
    }
    //todos los valores se mueven una columna a la derecha (esto a単ade una casilla a la derecha)
     for(i = (array_length_2d(growth, 1) -1); i &gt; -1; i -= 1)
    {
        for(z = 2; z &gt; -1; z -= 1)
        {
            growth[z, i+1] = growth[z, i];
        }
    }
    //columna [0] 
    growth[0, 0] = 0;
    growth[1, 0] = 0;
    growth[2, 0] = instance_create(x + (growth_distance/2), (y -2), obj_flower);
    //columna [array_length] --&gt;  fila [0] = 0, fila[1] = array_length, fila[2] instance create...
    growth[0, (array_length_2d(growth, 2))] = 0;
    growth[1, (array_length_2d(growth, 2))] = array_length_2d(growth, 2);
    growth[2, (array_length_2d(growth, 2))] = instance_create(x + (growth_distance/2) + (growth_distance * (array_length_2d(growth, 1))), (y -2), obj_flower);
    //mover plant a la izquierda "growth_distance" pixeles
    x = x - growth_distance;
    //chequea q cada ID.x = x + (growth_distance/2) + (growth_distance * growth[1, i]) 
    for(i = (array_length_2d(growth, 1))-1; i &gt; -1; i -= 1)
    {
        growth[2, i].x = x + (growth_distance/2) + (growth_distance * growth[1, i]);
    }
    //alarma para esperar a q "water_drop" se destruya (growth_alarm)
    growth_alarm = global.step_speed;
}

//Growth  water ----------------------------------------------------------------
//** falta 
//** checquear si los valores de las diferentes plantas crecen o no.
//** implementar difewrentes tama単os de planta
//** implementar que plant crezca hacia el lado contrario a water, una vez se ha extendido hasta water

if (instance_exists(obj_water)) &amp;&amp; (water == true) &amp;&amp; (growth_alarm &lt;= 0)    //si esta cerca de agua
{
    //definir hacia que lado esta water
    if ((abs(nearest_water.x - flower_left.x)) &lt; (abs(nearest_water.x - flower_right.x)))
    {
        water_left = true;
        water_right = false;
        nearest_flower_to_water = flower_left;
        farthest_flower_to_water = flower_right;
    }
    if ((abs(nearest_water.x - flower_left.x)) &gt;= (abs(nearest_water.x - flower_right.x)))
    {
        water_left = false;
        water_right = true;
        nearest_flower_to_water = flower_right;
        farthest_flower_to_water = flower_left;
    }
    
    if (nearest_flower_to_water.water_collision == false)  //plant no colisiona con water
    {
        if (water_right == true)   //crecer a la derecha
        {
            //nueva columna [array_length] 
            growth[0, (array_length_2d(growth, 2))] = 0;
            growth[1, (array_length_2d(growth, 2))] = array_length_2d(growth, 2);
            growth[2, (array_length_2d(growth, 2))] = instance_create(x + (growth_distance/2) + (growth_distance * (array_length_2d(growth, 1))), (y -2), obj_flower);
        }          
        if (water_left == true)   //crecer a la izquierda
        {
            //los valores de fila[1] suman +1 
            for(i = (array_length_2d(growth, 1) -1); i &gt; -1; i -= 1)
            {
                growth[1, i] += 1;
            }
            //todos los valores se mueven una columna a la derecha (esto crea una casilla a la derecha
            for(i = (array_length_2d(growth, 1) -1); i &gt; -1; i -= 1)
            {
                for(z = 2; z &gt; -1; z -= 1)
                {
                    growth[z, i+1] = growth[z, i];
                }
            }
            //columna [0] 
            growth[0, 0] = 0;
            growth[1, 0] = 0;
            growth[2, 0] = instance_create(x + (growth_distance/2), (y -2), obj_flower);
            //mover plant a la izquierda "growth_distance" pixeles
            x = x - growth_distance;
        }       
        //set growth_alarm
        growth_alarm = global.step_speed;
    }
    else    //si plant si colisiona con water
    {
        //calcular la posicion en[1, i] con valor mas alto en [0, i]
        for(i = (array_length_2d(growth, 1) -1); i &gt; -1; i -= 1)
        {
            value = 0;
            if growth[0, i] &gt; value 
            {
                value = growth[0, i];
                larger_flower = growth [1, i];
            }
        }
        //una de las flores colisiona con water, ya sea a izquierda o derecha.
        //si el valor [0,i] de la flower q colisiona es menor que "larger_flower", 
        //entonces la q colisiona y todas las casillas entre ella y "larger_flower" se equiparan a su valor
        if (water_left == true)
        {
            if (growth[0, 0] &lt; growth[0,larger_flower]) //flor agua es mas corta q larger_flower
            {
                growth[0, 0] += 1;//flor crece +1
                //set growth_alarm
                growth_alarm = global.step_speed;
            }
            else    //es mayor o igual
            {
                for(i = 0; i &lt; larger_flower; i +=1)   //desde posicion [1,0] check cada casilla hasta larger_flower
                {
                    if(growth[0, i] &lt; growth[0,larger_flower])    //valor [0,i] es menos q larger_flower
                    {
                        growth[0,i] += 1;
                        //set growth_alarm
                        growth_alarm = global.step_speed;
                        break;
                    }
                }
            }
        }
        if (water_right == true)
        {
            if (growth[0, (array_length_2d(growth, 1) -1)] &lt; growth[0,larger_flower]) //flor agua es mas corta q larger_flower
            {
                growth[0, (array_length_2d(growth, 1) -1)] += 1;//flor crece +1
                //set growth_alarm
                growth_alarm = global.step_speed;
            }
            else    //es mayor o igual
            {
                for(i = (array_length_2d(growth, 1) -1); i &gt; larger_flower; i -=1)   //desde posicion [1,0] check cada casilla hasta larger_flower
                {
                    if(growth[0, i] &lt; growth[0,larger_flower])    //valor [0,i] es menos q larger_flower
                    {
                        growth[0,i] += 1;
                        //set growth_alarm
                        growth_alarm = global.step_speed;
                        break;
                    }
                }
            }
        }
        /*
        if ((nearest_water.x - farthest_flower_to_water.x) &lt;= water_max_range)   //posicion mas alejada esta dentro de "water_max_range"
        {
            if(water_left == true)    //water a la izquierda, crece a la derecha
            {
                //nueva columna [array_length] 
                growth[0, (array_length_2d(growth, 2))] = 0;
                growth[1, (array_length_2d(growth, 2))] = array_length_2d(growth, 2);
                growth[2, (array_length_2d(growth, 2))] = instance_create(x + (growth_distance/2) + (growth_distance * (array_length_2d(growth, 1))), (y -2), obj_flower); 
                
            }
            if(water_right == true)    //water a la derecha, crece a la izquierda
            {
                //los valores de fila[1] suman +1 
                for(i = (array_length_2d(growth, 1) -1); i &gt; -1; i -= 1)
                {
                    growth[1, i] += 1;
                }
                //todos los valores se mueven una columna a la derecha (esto crea una casilla a la derecha
                for(i = (array_length_2d(growth, 1) -1); i &gt; -1; i -= 1)
                {
                    for(z = 2; z &gt; -1; z -= 1)
                    {
                     growth[z, i+1] = growth[z, i];
                    }
                }
                //columna [0] 
                growth[0, 0] = 0;
                growth[1, 0] = 0;
                growth[2, 0] = instance_create(x + (growth_distance/2), (y -2), obj_flower);
                //mover plant a la izquierda "growth_distance" pixeles
                x = x - growth_distance;
            }
            //set growth_alarm
            growth_alarm = global.step_speed;
        }
        */
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw Rectangle

draw_rectangle_colour(x, y-1, (x + (growth_distance * array_length_2d(growth, 1))), y+3, c_green, c_green, c_green, c_green, false);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
