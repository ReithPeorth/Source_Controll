<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_plant</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Parametros
image_speed = 0;
hsp = 0;
vsp = 0;

grav = true;    //variable q sirve para q obj externos activen y desactiven la gravedad de este obj


//Growth        ------------------------------------------------------------------------
//array que contiene:
// en la fila [0] el tamaño de la planta  
// en la fila [1] el numero de columna de la arrawy
// en la [2] la ID del sprite

//variables
growth_distance = global.unit/2;//la distancia entre los centros de cada sprite (y tamaño del sprite)
growth_rythm = 0;               //el tiempo q tarda en crecer
water = false;                  //guarda si se detecta water
water_drop = false;             //guarda si se detecta water_drop
water_range = global.unit*4;    //distancia a la q una fuente de agua hace crecer plant
water_max_range = global.unit;  //distancia maxima a la q plant crece desde el agua
nearest_water = 0;              //guarda la ID del water mas cercano
water_left = false;             //true si "nearest_water" esta a la izquierda
water_right = false;            //true si "nearest_water" esta a la derecha
nearest_flower_to_water = 0;    //guarda la ID de la "flower" mas cercana a water
farthest_flower_to_water = 0;   //guarda la ID de la "flower" mas lejana a water
flower_right = 0;               //flower mas a la derecha
flower_left = 0;                //flower mas a la izquierda
flower_centre = 0;              //flower central
plant_true_x = 0;
flower_even = 0;                //guarda si hay un numero par(true) o impar (false) de flores
nearest_water_drop = 0;         //guarda la ID del water_drop mas cercano
plant_centre = 0;               //guarda la ID de "flower" en la posicion central de la array
growth_alarm = 0;               //alarma para q solo crezca una vez por cada water_drop
larger_flower = 0;              //guarda la posicion en [1, i] del valor mas alto de [0, i]

growth[0, 2] = 0;
growth[0, 1] = 1;
growth[0, 0] = 0;

//array
for(z = 2; z &gt; -1; z -=1)   //guarda el numero de columna, para relaccionarlo en fila [2]
{
    growth[1, z] = z;
}


for(i = 2; i &gt; -1; i -= 1)  //guarda la ID de cada sprite, relaccionando su x con el numero de columna
{
    growth[2, i] = instance_create(x + (growth_distance/2) + (growth_distance *  i), (y -2), obj_flower);
}







</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//incluyo gravedad y colision por si acaso, pero no se si la necesitare en el futuro

//Gravity and Collision -------------------------------------------------------------
if grav == true     
{
    scr_grav();
}

scr_collision();
x += hsp;
y += vsp;

//Growth        ----------------------------------------------------------------------
//              ----------------------------------------------------------------------
//              ----------------------------------------------------------------------

//Al derramar agua sobre Plant, la array crece

//definir las ID de las flores importantes. Izq, Der y central-------------------------
//              -----------------------------------------------------------------------

//ID flower derecha e izquierda
flower_right = growth[2, (array_length_2d(growth, 1)-1)];
flower_left = growth[2, 0];
//ID de  flower central
//CUIDADO si es par, dara la ID de la flor a la IZQ del centro
flower_centre = growth[2,(array_length_2d(growth,1)/2)];

//esto averigua si el numero de flowers es par(true) o inpar(false)
if (frac((array_length_2d(growth, 1))/2) == 0) {flower_even = true;}
else flower_even = false;

//averigua el verdadero centro de Plant
if flower_even == true      //par
{
    plant_true_x = (flower_centre.x) + (growth_distance/2);
}
if flower_even == false     //impar
{
    plant_true_x = flower_centre.x;
}

//Water_drop check  --------------------------------------------------------------------
//                  --------------------------------------------------------------------
//loop q pasa por cada "casilla" de flor, comprueba si hay "water_drop" cerca, y devuelve "water_drop = true"
water_drop = false;     //reinicia la variable cada step para q solo crezca una vez

if instance_exists(obj_water_drop)
{
    for(i = (array_length_2d(growth, 1) -1); i &gt; -1; i -= 1)
    {
        nearest_water_drop = instance_nearest(growth[2, i].x, y, obj_water_drop);
        if ((nearest_water_drop.x - growth[2, i].x) &lt;= (growth_distance/2)) &amp;&amp; ((nearest_water_drop.y - growth[2, i].y) &lt;= (growth_distance/2))
        {
            water_drop = true;
            break    
        }
    }
}

//water check   -----------------------------------------------------------------------------
//              ------------------------------------------------------------------------------------

water = false;     //reinicia la variable cada step para q solo crezca una vez




if instance_exists(obj_water)
{
    //  (       ( agua +cerca de flower_right )             - (flower_right)  ) &lt;= water_range)  o (        lo mismo pero water_left                                                    )
    if (((instance_nearest(flower_right.x, y, obj_water).x) - (flower_right.x)) &lt;= water_range) || (((instance_nearest(flower_left.x, y, obj_water).x) - (flower_left.x)) &lt;= water_range)
    {
        water = true;
    }
    
    if water == true    //ID del Water mas cercano a la flor central (aprox) de Plant.
    {
        nearest_water = instance_nearest(plant_true_x, y, obj_water);
    }
}

//Growth water_drop     --------------------------------------------------------------------
if (growth_alarm &gt; 0) growth_alarm -=1;     //alarma para q solo crezca una vez cada cierto tiempo

if (instance_exists(obj_water_drop)) &amp;&amp; (water_drop == true) &amp;&amp; (growth_alarm &lt;= 0)      //regar planta
{
    //los valores de fila[0] suman +1 hasta un maximo de 3 
    for(i = (array_length_2d(growth, 1) -1); i &gt; -1; i -= 1)
    {
        if growth[0, i] &lt; 3
        {
            growth[0, i] += 1;
        }
    }
    //los valores de fila[1] suman +1 
    for(i = (array_length_2d(growth, 1) -1); i &gt; -1; i -= 1)
    {
        growth[1, i] += 1;
    }
    //todos los valores se mueven una columna a la derecha (esto añade una casilla a la derecha)
     for(i = (array_length_2d(growth, 1) -1); i &gt; -1; i -= 1)
    {
        for(z = 2; z &gt; -1; z -= 1)
        {
            growth[z, i+1] = growth[z, i];
        }
    }
    //columna [0] 
    growth[0, 0] = 0;
    growth[1, 0] = 0;
    growth[2, 0] = instance_create(x + (growth_distance/2), (y -2), obj_flower);
    //columna [array_length] --&gt;  fila [0] = 0, fila[1] = array_length, fila[2] instance create...
    growth[0, (array_length_2d(growth, 2))] = 0;
    growth[1, (array_length_2d(growth, 2))] = array_length_2d(growth, 2);
    growth[2, (array_length_2d(growth, 2))] = instance_create(x + (growth_distance/2) + (growth_distance * (array_length_2d(growth, 1))), (y -2), obj_flower);
    //mover plant a la izquierda "growth_distance" pixeles
    x = x - growth_distance;
    //chequea q cada ID.x = x + (growth_distance/2) + (growth_distance * growth[1, i]) 
    for(i = (array_length_2d(growth, 1))-1; i &gt; -1; i -= 1)
    {
        growth[2, i].x = x + (growth_distance/2) + (growth_distance * growth[1, i]);
    }
    //alarma para esperar a q "water_drop" se destruya (growth_alarm)
    growth_alarm = global.step_speed;
}

//Growth  water ----------------------------------------------------------------
//** falla algo del crecimiento y los distintos rangos. HAy que hacer chequeos. Parece tener q ver con que el icono de interaccion aparece en la parte izquierda de Plant
//** cambiar la x de Plant para q sea el centro del sprite. Espero q no haya q cambiar el sistema
//**el problema esta en q Plant esta a la izquierda cuando esta a la derecha

if (instance_exists(obj_water)) &amp;&amp; (water == true) &amp;&amp; (growth_alarm &lt;= 0)    //si esta cerca de agua
{
    //definir hacia que lado esta water
    if ((nearest_water.x - growth[2, 0].x)&gt;(nearest_water.x - growth[2, (array_length_2d(growth, 2)-1)].x))
    {
        water_left = true;
        water_right = false;
        nearest_flower_to_water = growth[2, 0];
        farthest_flower_to_water = growth[2, (array_length_2d(growth, 2)-1)];;
    }
    if ((nearest_water.x - growth[2, 0].x)&lt;=(nearest_water.x - growth[2, (array_length_2d(growth, 2)-1)].x))
    {
        water_left = false;
        water_right = true;
        nearest_flower_to_water = growth[2, (array_length_2d(growth, 2)-1)];
        farthest_flower_to_water = growth[2, 0];;
    }
    
    if (nearest_flower_to_water.water_collision == false)  //plant no colisiona con water
    {
        if (water_right == true)   //crecer a la derecha
        {
            //nueva columna [array_length] 
            growth[0, (array_length_2d(growth, 2))] = 0;
            growth[1, (array_length_2d(growth, 2))] = array_length_2d(growth, 2);
            growth[2, (array_length_2d(growth, 2))] = instance_create(x + (growth_distance/2) + (growth_distance * (array_length_2d(growth, 1))), (y -2), obj_flower);
        }          
        if (water_left == true)   //crecer a la izquierda
        {
            //los valores de fila[1] suman +1 
            for(i = (array_length_2d(growth, 1) -1); i &gt; -1; i -= 1)
            {
                growth[1, i] += 1;
            }
            //todos los valores se mueven una columna a la derecha (esto crea una casilla a la derecha
            for(i = (array_length_2d(growth, 1) -1); i &gt; -1; i -= 1)
            {
                for(z = 2; z &gt; -1; z -= 1)
                {
                    growth[z, i+1] = growth[z, i];
                }
            }
            //columna [0] 
            growth[0, 0] = 0;
            growth[1, 0] = 0;
            growth[2, 0] = instance_create(x + (growth_distance/2), (y -2), obj_flower);
            //mover plant a la izquierda "growth_distance" pixeles
            x = x - growth_distance;
        }       
        //set growth_alarm
        growth_alarm = global.step_speed;
    }
    else    //si plant si colisiona con water
    {
        //calcular la posicion en[1, i] con valor mas alto en [0, i]
        for(i = (array_length_2d(growth, 1) -1); i &gt; -1; i -= 1)
        {
            value = 0;
            if growth[0, i] &gt; value 
            {
                value = growth[0, i];
                larger_flower = growth [1, i];
            }
        }
        //una de las flores colisiona con water, ya sea a izquierda o derecha.
        //si el valor [0,i] de la flower q colisiona es menor que "larger_flower", 
        //entonces la q colisiona y todas las casillas entre ella y "larger_flower" se equiparan a su valor
        if (water_left == true)
        {
            if (growth[0, 0] &lt; growth[0,larger_flower]) //flor agua es mas corta q larger_flower
            {
                growth[0, 0] += 1;//flor crece +1
                //set growth_alarm
                growth_alarm = global.step_speed;
            }
            else    //es mayor o igual
            {
                for(i = 0; i &lt; larger_flower; i +=1)   //desde posicion [1,0] check cada casilla hasta larger_flower
                {
                    if(growth[0, i] &lt; growth[0,larger_flower])    //valor [0,i] es menos q larger_flower
                    {
                        growth[0,i] += 1;
                        //set growth_alarm
                        growth_alarm = global.step_speed;
                        break;
                    }
                }
            }
        }
        if (water_right == true)
        {
            if (growth[0, (array_length_2d(growth, 1) -1)] &lt; growth[0,larger_flower]) //flor agua es mas corta q larger_flower
            {
                growth[0, (array_length_2d(growth, 1) -1)] += 1;//flor crece +1
                //set growth_alarm
                growth_alarm = global.step_speed;
            }
            else    //es mayor o igual
            {
                for(i = (array_length_2d(growth, 1) -1); i &gt; larger_flower; i -=1)   //desde posicion [1,0] check cada casilla hasta larger_flower
                {
                    if(growth[0, i] &lt; growth[0,larger_flower])    //valor [0,i] es menos q larger_flower
                    {
                        growth[0,i] += 1;
                        //set growth_alarm
                        growth_alarm = global.step_speed;
                        break;
                    }
                }
            }
        }
        /*
        if ((nearest_water.x - farthest_flower_to_water.x) &lt;= water_max_range)   //posicion mas alejada esta dentro de "water_max_range"
        {
            if(water_left == true)    //water a la izquierda, crece a la derecha
            {
                //nueva columna [array_length] 
                growth[0, (array_length_2d(growth, 2))] = 0;
                growth[1, (array_length_2d(growth, 2))] = array_length_2d(growth, 2);
                growth[2, (array_length_2d(growth, 2))] = instance_create(x + (growth_distance/2) + (growth_distance * (array_length_2d(growth, 1))), (y -2), obj_flower); 
                
            }
            if(water_right == true)    //water a la derecha, crece a la izquierda
            {
                //los valores de fila[1] suman +1 
                for(i = (array_length_2d(growth, 1) -1); i &gt; -1; i -= 1)
                {
                    growth[1, i] += 1;
                }
                //todos los valores se mueven una columna a la derecha (esto crea una casilla a la derecha
                for(i = (array_length_2d(growth, 1) -1); i &gt; -1; i -= 1)
                {
                    for(z = 2; z &gt; -1; z -= 1)
                    {
                     growth[z, i+1] = growth[z, i];
                    }
                }
                //columna [0] 
                growth[0, 0] = 0;
                growth[1, 0] = 0;
                growth[2, 0] = instance_create(x + (growth_distance/2), (y -2), obj_flower);
                //mover plant a la izquierda "growth_distance" pixeles
                x = x - growth_distance;
            }
            //set growth_alarm
            growth_alarm = global.step_speed;
        }
        */
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw Rectangle

draw_rectangle_colour(x, y-1, (x + (growth_distance * array_length_2d(growth, 1))), y+3, c_green, c_green, c_green, c_green, false);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
